11.19 02:16
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <chrono>
#include <string>
using namespace std;

vector<vector<string>> maze;
vector<vector<bool>> correctPath;
vector<vector<bool>> visited;
int W, H;
int playerX, playerY;
int exitX, exitY;
bool gameOver = false;
bool showCorrectPath = false;
const string playerChar = "\033[32mo\033[0m";
const string clownChar = "\033[31mğŸ¤¡\033[0m"; // ä¸»è§’å˜å°ä¸‘æ ·å¼
bool isGameCleared = false;
const string WALL = "â– ";
const string PATH = " ";
const string EXIT_CHAR = "\033[95mx\033[0m";
const string BORDER_TEXT = "\033[91m";
const string FINAL_TEXT = "ä½ èµ°å‡ºäº†è¿·å®«ï¼Œå´æ²¡èµ°è¿›å¥¹çš„å†…å¿ƒ";
const string GIRL_EMOJI = "\033[93m\033[0m";
const string GIRL_SPEECH = "\033[93må“ˆå“ˆå“ˆå“ˆå“ˆçœŸæ˜¯å°ä¸‘\033[0m";

// è®¡æ—¶ç›¸å…³
bool isInfiniteTime = false;
int remainingTime = 0;
chrono::steady_clock::time_point startTime;
chrono::steady_clock::time_point lastRefreshTime;

// æçŸ­å»¶è¿Ÿï¼ˆé™ä½CPUå ç”¨ï¼‰
void delayTiny() {
    for (long long i=0; i<1e5; i++);
}

// è¶…æ…¢å»¶è¿Ÿï¼ˆçº¦2ç§’ï¼Œç”¨äºåŠ¨ç”»æ…¢æ”¾ï¼‰
void delayUltraSlow() {
    for (long long i=0; i<2e7; i++);
}

// è®¡ç®—å‰©ä½™æ—¶é—´
int getRemainingTime() {
    if (isInfiniteTime) return -1;
    auto now = chrono::steady_clock::now();
    auto elapsed = chrono::duration_cast<chrono::seconds>(now - startTime).count();
    return max(0, remainingTime - (int)elapsed);
}

// é€‰æ‹©æ—¶é—´æ¨¡å¼
void chooseTimeMode() {
    cout << BORDER_TEXT << "===== é€‰æ‹©æ—¶é—´æ¨¡å¼ =====" << "\033[0m" << endl;
    cout << "1=æ— é™æ—¶é—´ 2=é™åˆ¶æ—¶é—´ï¼ˆè¾“å…¥ç§’æ•°ï¼‰" << endl;
    cout << "è¾“å…¥æ•°å­—é€‰æ‹©ï¼š";
    int choice;
    while (!(cin >> choice)) {
        cin.clear();
        cin.ignore(1000, '\n');
        cout << "è¾“å…¥é”™è¯¯ï¼è¯·è¾“å…¥1æˆ–2ï¼š";
    }

    if (choice == 1) {
        isInfiniteTime = true;
        remainingTime = 0;
    } else {
        isInfiniteTime = false;
        cout << "è¯·è¾“å…¥é™åˆ¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼š";
        while (!(cin >> remainingTime) || remainingTime <= 0) {
            cin.clear();
            cin.ignore(1000, '\n');
            cout << "è¾“å…¥é”™è¯¯ï¼è¯·è¾“å…¥æ­£æ•´æ•°ï¼š";
        }
        startTime = chrono::steady_clock::now();
    }
    lastRefreshTime = chrono::steady_clock::now();
    system("clear");
}

// ç”Ÿæˆè¿·å®«ï¼ˆä¿®å¤è¾¹è§’å¯¹é½ï¼‰
void generateMazeDFS(int x, int y) {
    maze[y][x] = PATH;
    int dirs[4][2] = {{0,2}, {0,-2}, {2,0}, {-2,0}};
    for (int i=0; i<4; i++) swap(dirs[i], dirs[rand()%4]);
    
    for (int i=0; i<4; i++) {
        int nx = x + dirs[i][0];
        int ny = y + dirs[i][1];
        if (nx >=1 && nx < W-1 && ny >=1 && ny < H-1 && maze[ny][nx] == WALL) {
            maze[ny - dirs[i][1]/2][nx - dirs[i][0]/2] = PATH;
            generateMazeDFS(nx, ny);
        }
    }
}

bool dfsGuidePath(int x, int y) {
    if (x == exitX && y == exitY) {
        correctPath[y][x] = true;
        return true;
    }
    if (x < 1 || x >= W-1 || y < 1 || y >= H-1 || maze[y][x] == WALL || visited[y][x]) {
        return false;
    }
    
    visited[y][x] = true;
    if (dfsGuidePath(x+1, y) || dfsGuidePath(x-1, y) || dfsGuidePath(x, y+1) || dfsGuidePath(x, y-1)) {
        correctPath[y][x] = true;
        return true;
    }
    return false;
}

void generateMaze(int mode) {
    W = (mode == 1) ? 17 : 23;
    H = (mode == 1) ? 11 : 15;
    maze.resize(H, vector<string>(W, WALL)); // åˆå§‹åŒ–å…¨å¢™
    correctPath.resize(H, vector<bool>(W, false));
    visited.resize(H, vector<bool>(W, false));

    // å¼ºåˆ¶è®¾ç½®è¾¹ç•Œä¸ºå¢™ï¼ˆä¿®å¤è¾¹è§’å¯¹é½ï¼‰
    for (int x=0; x<W; x++) {
        maze[0][x] = WALL;
        maze[H-1][x] = WALL;
    }
    for (int y=0; y<H; y++) {
        maze[y][0] = WALL;
        maze[y][W-1] = WALL;
    }

    generateMazeDFS(1, 1);

    playerX = 1;
    playerY = 1;
    maze[playerY][playerX] = playerChar;
    maze[0][1] = BORDER_TEXT + "é˜¿" + "\033[0m";
    maze[0][2] = BORDER_TEXT + "æ°" + "\033[0m";
    maze[0][3] = BORDER_TEXT + "è¿·" + "\033[0m";
    maze[0][4] = BORDER_TEXT + "å®«" + "\033[0m";
    for (int x=5; x<W; x++) maze[0][x] = WALL;

    exitX = W - 2;
    exitY = H - 2;
    maze[exitY][exitX] = EXIT_CHAR;

    dfsGuidePath(playerX, playerY);
}

void chooseDifficulty() {
    cout << BORDER_TEXT << "===== é˜¿æ°è¿·å®« =====" << "\033[0m" << endl;
    cout << "1=ç®€å•æ¨¡å¼ï¼ˆå°è¿·å®«ï¼‰ 2=å›°éš¾æ¨¡å¼ï¼ˆå¤§è¿·å®«ï¼‰" << endl;
    cout << "è¾“å…¥æ•°å­—é€‰æ‹©ï¼š";
    int diff;
    while (!(cin >> diff) || (diff != 1 && diff != 2)) {
        cin.clear();
        cin.ignore(1000, '\n');
        cout << "è¾“å…¥é”™è¯¯ï¼è¯·è¾“å…¥1æˆ–2ï¼š";
    }
    generateMaze(diff);
}

// ç»˜åˆ¶é€šå…³ç•Œé¢ï¼ˆä¸»è§’åœ¨æ–‡æ¡ˆå‰ï¼Œç¾å¥³å°è¯åœ¨å³ä¾§ï¼‰
void drawé€šå…³ç•Œé¢(string playerStyle, int girlX) {
    system("clear");
    // æ–‡æ¡ˆåŒºåŸŸï¼ˆä¸»è§’ä½äºæ–‡æ¡ˆä¸‹æ–¹ï¼‰
    cout << BORDER_TEXT << "===== æ­å–œé€šå…³ï¼=====" << "\033[0m" << endl;
    cout << FINAL_TEXT << endl;
    cout << BORDER_TEXT << "=====================" << "\033[0m" << endl;
    
    // è§’è‰²åŒºåŸŸï¼ˆä¸»è§’åœ¨æ–‡æ¡ˆæ­£ä¸‹æ–¹ï¼‰
    int playerY_pos = 3; // æ–‡æ¡ˆä¸‹æ–¹çš„ä½ç½®
    for (int y=0; y<H; y++) {
        for (int x=0; x < max(W, girlX + 20); x++) { // æ‰©å±•åŒºåŸŸå®¹çº³å°è¯
            // ä¸»è§’ï¼ˆæ–‡æ¡ˆæ­£ä¸‹æ–¹ï¼‰
            if (x == 5 && y == playerY_pos) {
                cout << playerStyle;
            }
            // ç¾å¥³
            else if (x == girlX && y == playerY_pos) {
                cout << GIRL_EMOJI;
                // ç¾å¥³å³ä¾§æ˜¾ç¤ºå°è¯
                if (girlX <= 6) {
                    cout << " " << GIRL_SPEECH;
                }
            }
            else {
                cout << " ";
            }
        }
        cout << endl;
    }
}

// ä¸»å¾ªç¯
void mainLoop() {
    char c;
    // åˆå§‹åŒ–ç•Œé¢
    system("clear");
    int remTime = getRemainingTime();
    cout << "å½“å‰æ—¶é—´ï¼š";
    if (isInfiniteTime) {
        cout << "\033[32mæ— é™æ—¶é—´\033[0m" << endl;
    } else {
        cout << "\033[31må‰©ä½™" << remTime << "ç§’\033[0m" << endl;
    }
    for (int y=0; y<H; y++) {
        for (int x=0; x<W; x++) {
            if (x == playerX && y == playerY) cout << playerChar;
            else if (x == exitX && y == exitY) cout << EXIT_CHAR;
            else if (showCorrectPath && correctPath[y][x]) cout << "\033[34mâ†’\033[0m";
            else cout << maze[y][x];
        }
        cout << endl;
    }
    cout << "\nW=ä¸Š S=ä¸‹ A=å·¦ D=å³ | æŒ‰Mæ˜¾ç¤ºè·¯çº¿ | Q=é€€å‡º" << endl;

    while (!gameOver && !isGameCleared) {
        auto now = chrono::steady_clock::now();
        // æ¯0.3ç§’åˆ·æ–°ä¸€æ¬¡ç•Œé¢
        if (chrono::duration_cast<chrono::milliseconds>(now - lastRefreshTime).count() >= 300) {
            system("clear");
            int remTime = getRemainingTime();
            cout << "å½“å‰æ—¶é—´ï¼š";
            if (isInfiniteTime) {
                cout << "\033[32mæ— é™æ—¶é—´\033[0m" << endl;
            } else {
                if (remTime <= 0) {
                    cout << "\033[31mæ—¶é—´å·²åˆ°ï¼æ¸¸æˆç»“æŸ\033[0m" << endl;
                    gameOver = true;
                    for (int i=0; i<3; i++) delayTiny();
                    return;
                }
                cout << "\033[31må‰©ä½™" << remTime << "ç§’\033[0m" << endl;
            }
            for (int y=0; y<H; y++) {
                for (int x=0; x<W; x++) {
                    if (x == playerX && y == playerY) cout << playerChar;
                    else if (x == exitX && y == exitY) cout << EXIT_CHAR;
                    else if (showCorrectPath && correctPath[y][x]) cout << "\033[34mâ†’\033[0m";
                    else cout << maze[y][x];
                }
                cout << endl;
            }
            cout << "\nW=ä¸Š S=ä¸‹ A=å·¦ D=å³ | æŒ‰Mæ˜¾ç¤ºè·¯çº¿ | Q=é€€å‡º" << endl;
            lastRefreshTime = now;
        }

        // å®æ—¶å¤„ç†è¾“å…¥
        if (cin >> c) {
            if (c == 'm' || c == 'M') {
                showCorrectPath = !showCorrectPath;
            } else if (c == 'q' || c == 'Q') {
                gameOver = true;
                return;
            } else {
                int nx = playerX, ny = playerY;
                if (c == 'w') ny--;
                else if (c == 's') ny++;
                else if (c == 'a') nx--;
                else if (c == 'd') nx++;

                if (nx >=1 && nx < W-1 && ny >=1 && ny < H-1 && maze[ny][nx] != WALL) {
                    maze[playerY][playerX] = PATH;
                    playerX = nx;
                    playerY = ny;
                    maze[playerY][playerX] = playerChar;

                    // é€šå…³åŠ¨ç”»
                    if (playerX == exitX && playerY == exitY) {
                        isInfiniteTime = true;
                        isGameCleared = true;
                        
                        // 1. ç¬‘è„¸æ…¢æ”¾åœç•™8ç§’ï¼ˆä¸»è§’åœ¨æ–‡æ¡ˆå‰ï¼‰
                        drawé€šå…³ç•Œé¢(playerChar, W + 10);
                        cout << "" << endl;
                        for (int i=0; i<4; i++) delayUltraSlow();

                        // 2. å¿ƒç¢æ…¢æ”¾åœç•™5ç§’
                        drawé€šå…³ç•Œé¢(playerChar, W + 10);
                        cout << "" << endl;
                        for (int i=0; i<3; i++) delayUltraSlow();

                        // 3. ç¾å¥³ä»æœ€å³ä¾§æ…¢èµ°åˆ°ä¸»è§’æ—
                        int girlX = W + 10;
                        int targetX = 6; // ä¸»è§’å³ä¾§ä½ç½®
                        while (girlX > targetX && !gameOver) {
                            drawé€šå…³ç•Œé¢(playerChar, girlX);
                            girlX--;
                            delayUltraSlow();
                        }

                        // 4. ä¸»è§’å˜å°ä¸‘æ…¢æ”¾åœç•™8ç§’
                        drawé€šå…³ç•Œé¢(clownChar, targetX);
                        for (int i=0; i<4; i++) delayUltraSlow();
                        
                        gameOver = true;
                        return;
                    }
                }
            }
            // è¾“å…¥åç«‹å³åˆ·æ–°
            system("clear");
            int remTime = getRemainingTime();
            cout << "å½“å‰æ—¶é—´ï¼š";
            if (isInfiniteTime) {
                cout << "\033[32mæ— é™æ—¶é—´\033[0m" << endl;
            } else {
                cout << "\033[31må‰©ä½™" << remTime << "ç§’\033[0m" << endl;
            }
            for (int y=0; y<H; y++) {
                for (int x=0; x<W; x++) {
                    if (x == playerX && y == playerY) cout << playerChar;
                    else if (x == exitX && y == exitY) cout << EXIT_CHAR;
                    else if (showCorrectPath && correctPath[y][x]) cout << "\033[34mâ†’\033[0m";
                    else cout << maze[y][x];
                }
                cout << endl;
            }
            cout << "\nW=ä¸Š S=ä¸‹ A=å·¦ D=å³ | æŒ‰Mæ˜¾ç¤ºè·¯çº¿ | Q=é€€å‡º" << endl;
            lastRefreshTime = chrono::steady_clock::now();
        }

        delayTiny();
    }
}

int main() {
    srand((unsigned int)time(NULL));
    chooseDifficulty();
    chooseTimeMode();
    mainLoop();
    return 0;
}
    
